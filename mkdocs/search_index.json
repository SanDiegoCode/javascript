{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to Javascript\n\n\nHere you will learn the basics of javascript.\n\n\nFAQs\n\n\n\n\nWhere do I run the code?\n\n\nGo to \ncodepen\n\n\nWe suggest creating an account to save your progress \n\n\n\n\n\n\n\n\n\n\nWhat if I need help?\n\n\nWe're only an \nemail away\n\n\n\n\n\n\nWhat if I'm not a part of SD Code?\n\n\nDon't worry about it! This resource is free to use by anyone!\n\n\n\n\n\n\nCan I host this on my website?\n\n\nSure, as long as you give credit and link it to our website\n\n\n\n\n\n\nHow can I contribute?\n\n\nSubmit a pull request to the repository on \nGithub\n\n\n\n\n\n\n\n\nCreators\n\n\n\n\nRonak Shah\n\n\nNicholas Spencer", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-javascript", 
            "text": "Here you will learn the basics of javascript.", 
            "title": "Welcome to Javascript"
        }, 
        {
            "location": "/#faqs", 
            "text": "Where do I run the code?  Go to  codepen  We suggest creating an account to save your progress       What if I need help?  We're only an  email away    What if I'm not a part of SD Code?  Don't worry about it! This resource is free to use by anyone!    Can I host this on my website?  Sure, as long as you give credit and link it to our website    How can I contribute?  Submit a pull request to the repository on  Github", 
            "title": "FAQs"
        }, 
        {
            "location": "/#creators", 
            "text": "Ronak Shah  Nicholas Spencer", 
            "title": "Creators"
        }, 
        {
            "location": "/BeginnerJavascript/", 
            "text": "A Beginner's Guide to Javascript by Gunner Spencer\n\n\nHello there! Welcome to this course that will teach you all of the basics of the Javascript programming language. Javascript allows us to program applications and webpages for the web browser (like Google Chrome or Internet Explorer). Think of it as the brains of the operation, that works on the client side (which means it doesn't talk to the server), in order to provide your webpage with functionality. Let's just jump right in to start getting a better understanding!\n\n\nProject Setup\n\n\nYou will need a text editor (I recommend Atom.io or Textwrangler), but even Notepad will do. Setup a folder that will contain all of the files for this project, and name it something like JavascriptGuide (or don't, name it dankmemes if you want). And thats it! Open up your text editor and if you are using a more advanced text editor you can open up the path for your project folder and advance to the next step (don't worry if you can't, you will probably just need to leave the folder open in your system's file tree, i.e. Finder for Mac, so you can quickly access files inside of it.)\n\n\nPart 1: Two Worlds Collide, HTML \n Javascript\n\n\nThe first thing we need to do before we even begin writing any Javascript is to create an \nindex.html\n file. To do this, use your text editor to create a new file, then save that file as \nindex.html\n.\n\n\nNOTE: Whenever you make changes to any file, you have to save it before seeing those changes reflected in the browser.\n\n\n!DOCTYPE html\n\n\nhtml\n  \n    \nhead\n\n        \ntitle\n Javascript Tutorial \n/title\n\n    \n/head\n\n    \nbody\n\n        \nscript src=\"main.js\"\n/script\n\n    \n/body\n\n\n/html\n\n\n\n\nThis just creates a basic HTML page that we can open up with the web browser of our choice (find the \nindex.html\n file and right click it, then press open with and select the web browser). All we are doing on this webpage is giving it a title: \nJavascript Tutorial\n and then in our \nbody\n tags, creating \nscript\n tags to import our Javascript file by setting \nsrc\n, standing for source, to our \nmain.js\n file, which we will create next.\n\n\nPart 2: O, Where art Thou, Variables\n\n\nNow it's time for our \nmain.js\n file! Create it in the same way you created the \nindex.html\n file, except of course with our new name, \nmain.js\n. Notice that a Javascript file will always have the extension \n.js\n. This lets the browser know what type of file it is.\n\n\nOpen up your \nmain.js\n and type the following:\n\n\nvar MyVariable = \"Hello World!\";\n\nconsole.log(MyVariable);\n\n\n\nNow save this file and refresh your webpage. Nothing happened! Or so it seems. Right click the browser screen (if you are using Safari, switch to another browser, otherwise this won't work), and press Inspect Element, or Inspect. A box should pop up somewhere on your browser window that has the HTML code we wrote for our \nindex.html\n file. Go to the top of that box and click where it says \nConsole\n. Here you will see the output of our function we just called, \nconsole.log\n. \n\n\nTo call a function is to make that piece of code inside the function run. We pass what are called \nparameters\n to functions, the things inside the parentheses of the function call. These are used by the function, like how \nconsole.log(text)\n takes in the parameter \ntext\n to output to the console.\n\n\nThe parameter that we passed into the function was actually a variable, specifically, \nMyVariable\n, which had a value of \n\"Hello World!\"\n. Variables are found in all programming langauges, as they allow us to store data for later use in our program. There are different types of data, for example: numbers, strings (which are just words or letters, like the value of \nMyVariable\n), and booleans. By creating a variable, we can, instead of using the string \n\"Hello World!\"\n, just use the name of the variable, \nMyVariable\n, in its place. The same goes for numbers in mathematical operations (which we will see in a moment) or boolean values (true or false) in conditional statements. \n\n\nBelow are examples of the different variables, including numbers, and the mathematical operations we can do with them.\n\n\nvar count = 5; // just a number\nvar num = 10.5; // a floating point number, or decimal\nvar product = count * num; // multiplication operator\nvar quotient = num / count; // division operator\nvar added = count + num; // addition operator\nvar subtracted = num - count; // subtraction operator\n\nproduct = quotient * added; \n/* notice that we don't have to add the keyword var \nafter we already created the variable. */\n\nsubtracted = product - subtracted; \n/* we can use the variable we are assigning a value to \ninside of the right-hand operation */\n\nvar crazyOperation = ((count * 5) / (product + added)) * quotient / 1.5; \n/* this demonstrates the order of operations, which is \nthe same as in your regular math class, but we use \nparentheses for nested statements that we want to make \nsure get evaluated first */\n\n\n\nTry these out, using \nconsole.log\n to view the values you get. The \n//\n is a single line comment, so everything else after the \n//\n in that line is ignored. Same thing with the \n/*   multiline comment   */\n which can span multiple lines. Just make sure you open up with \n/*\n and then write your comment, then close it \n*/\n.\n\n\nvar firstName = \"Johnny\";\nvar lastName = \"Appleseed\";\nvar fullName = firstName + \" \" + lastName;\n\nvar nameSize = fullName.length;\n\n\n\nThese are examples of how you can use \nstrings\n, the data type that allows you to store letters/characters in a variable. Note that \nstrings\n have built-in attributes, like the \nlength\n attribute that returns the length of that string. Also, we can combine, or concat, \nstring\n with \n+\n signs. That's how we get the value for our \nfullName\n variable. Try using \nconsole.log\n to view the values!\n\n\nvar continue = false;\n// some stuff we do before we continue\ncontinue = true;\n\n\n\nThis is a boolean variable. It holds the value of either \ntrue\n or \nfalse\n, which will allow us to evaluate conditional statements, a concept we will jump into next.\n\n\nPart 3: It's True, Javascript is the Language for You\n\n\nThis next concept is crucial to programming. It is the conditional statement, which essentially checks if a condition is true or false, then does something accordingly. In Javascript, we have a few of these:\n\n\nvar count = 5,\n    measure = 20;\n\nif(count \n measure) {\n    console.log(\"count is less than measure\");\n    if(count \n measure / count) {\n        console.log(\"we can put if statements inside of if statements, and also use mathematical operations in the condition brackets!\");\n    }\n} else {\n    console.log(\"this code would run if the condition was not true.\");\n}\n\n\n\nThis is the most fundamental conditional statement, the \nif else\n statement. It checks if the condition inside the parentheses is true, and if it is it executes the code inside of the curly brackets. Otherwise, it executes the code following the \nelse\n keyword. There are a few conditional operators we can use to compare values: \n==, \n, \n, \n=, \n=, !=\n. These are pretty intuitive, meaning is equal to, greater than, less than, greater than or equal to, less than or equal to, and is not equal to, respectively. \n\n\nvar count = 0;\nwhile(count \n 10) {\n    console.log(count);\n    count++; // same thing as count += 1, count = count + 1\n}\n\n\n\nThis is a \nwhile\n loop, which executes the code inside the curly braces while the condition in the parentheses is true. Test out this piece of code, even see if you can make it count by two's or three's. \n\n\nfor(var count = 0; count \n 10; count++) {\n    console.log(count);\n}\n\n\n\nThis is a \nfor\n loop, which essentially combines the components of a \nwhile\n loop necessary for iteration into one concise statement. This does the exact same thing as the previous conditional loop, except the syntax is different, since the iterator (or variable we increment) is declared inside the \nfor\n statement, along with the condition to check and the iteration command \ncount++\n.\n\n\nPart 4: Putting the Fun in Functions\n\n\nSo far we have looked at Javascript code that executes in a linear fashion. This means that the Javascript engine, which runs our code, is starting from the top of our file and executes the code line by line until it reaches the end. Things like conditional statements and loops can skip over certain pieces of code, but for the most part, there is only linear progression. This is great, except for what if we wanted to do the same thing in two places in our code? Would we have to rewrite the same code? No! That's where functions come in. Functions act as blocks that contain code we can execute from anywhere in our program, again and again. We have already seen examples of this, like \nconsole.log\n, which receives a parameter, like the text we want to output, and uses it inside of the code contained in that function. Let's take a look at how a function works in code!\n\n\nfunction addTwoNumbers(num1, num2) {\n    var result = num1 + num2;\n    return result;\n}\n\n\n\nThis is a super simple function that takes in two parameters, \nnum1\n and \nnum2\n and adds them, storing that value in a variable we declare inside of the function called \nresult\n, then we return that \nresult\n.\nThis is how it could be used in practice:\n\n\nconsole.log(\"2 + 5 is \" + addTwoNumbers(2, 5));\n\n\n\nSure, not super useful, since we could just handwrite that code just as fast as calling the function. However, as your computations or logic gets more complex, you need to organize it into functions, lest you wish to go insane. Here is a good example of this:\n\n\nfunction raiseToPower(num, exponent) {\n    var result = 1;\n    for(var k = 0; k \n exponent; k++) {\n        result *= num;\n    }\n    return result;\n}\n\n\n\nThis function is a bit more complex than just adding two powers, because as you might be able to tell, it raises a \nnum\n to an \nexponent\n and returns that \nresult\n. This is still a fairly simple example, but you can see how it would be necessary to have a function like this rather than rewriting the tedious code everytime you wanted to use it. \n\n\nPart 5: Simple DOM for your Dome\n\n\nSo far we have only been manipulating variables we have created in our Javascript file, with no real effect on our webpage. DOM, which stands for the Document Object Model, solves this! DOM allows us to interact with our HTML elements so we can change our webpage from Javascript! Let's take a look at a few examples:\n\n\nindex.html\n\n\n    \n!DOCTYPE html\n\n\nhtml\n  \n    \nhead\n\n        \ntitle\n Javascript Tutorial \n/title\n\n    \n/head\n\n    \nbody\n\n        \n!-- NEW STUFF --\n\n            \ndiv id=\"myDiv\"\n/div\n\n            \ndiv class=\"coolClass\"\n/div\n\n            \ndiv class=\"coolClass\"\n/div\n\n        \n!-- END OF NEW STUFF --\n\n        \nscript src=\"main.js\"\n/script\n\n    \n/body\n\n\n/html\n\n\n\n\nmain.js\n\n\nvar myDivVariable = document.getElementById(\"myDiv\");\nvar theCoolClassVariable = document.getElementsByClassName(\"coolClass\");\n\nmyDivVariable.innerHTML = \"Hello, folks!\";\n\nfor(var k = 0; k \n theCoolClassVariable.length; k++) {\n    theCoolClassVariable[k].innerHTML = \"This is a part of the cool class\";\n}\n\ndocument.body.style.backgroundColor = \"red\";\ndocument.body.style.color = \"white\";\n\n\n\nA lot to unpack here. The first thing we notice are these two variables we created: \nmyDivVariable\n and \ntheCoolClassVariable\n. These each store the value returned by a built-in DOM function. \ndocument.getElementById(id)\n returns the element that matches that id from the HTML file. In this case, we would return the \ndiv\n with an \nid\n of \nmyDiv\n. The next DOM function, \ndocument.getElementsByClassName(name)\n returns an \narray\n of all the elements whose class matches that name. Essentially, an array is a data type that can store multiple values, and you can access those values by using square bracets \n[index]\n where the \nindex\n starts at \n0\n and goes up to the \narray.length - 1\n, whatever that may be. Before we move on, here is a quixk example of arrays:\n\n\nvar myList = [\"hello\", \"my\", \"name\", \"is\", \"fred\"];\nvar fullSentence = \"\";\nfor(var k = 0; k \n myList.length; k++) {\n    fullSentence += myList[k] + \" \";\n}\nconsole.log(fullSentence);\n\nconsole.log(\"The first word is \" + myList[0]);\nconsole.log(\"The last word is \" + myList[4]);\n\n\n\nTry running this example and see the output. Arrays can also store numbers, booleans, or objects like our DOM function \ndocument.getElementsByClassName\n returns.\n\n\nNow, back to the DOM example.\n\n\nThe property \ninnerHTML\n of a DOM object allows us to manipulate whatever is inside of the tags. We could even add in another HTML element with this! \n\n\ndocument.body.innerHTML += \"\ndiv id='yolo'\n/div\n\";\ndocument.getElementById(\"yolo\").innerHTML = \"yolo div\";\n\n\n\nThis is an easy way of manipulating our DOM, but not the best. It gets messy writing HTML is Javascript as a string. Notice that when we added the \ndiv\n with \ninnerHTML\n and gave it an \nid\n we had to use \n''\n single quotes instead of \n\"\"\n double quotes. This is because using two sets of double quotes would confuse the Javascript engine and give us an error. Theres a better way to create and add DOM objects in Javascript that we will go into in a moment.\n\n\nThe next thing we need to unpack is the \nstyle\n property of our DOM objects. We were able to manipulate the CSS of our HTML objects using this \nstyle\n property. \n\n\nCSS\n\n\ndiv {\n    background-color: red;\n}\n\n\n\nJavascript\n\n\nmyObject.style.backgroundColor = \"red\";\n\n\n\nThese two statements, written in different languages, do the same thing, assuming they are both pointing to the same object. Take note of the syntax differences between them, like how in Javascript there aren't any \n-\n's and instead the first letter of the next word is capitalized. This practice is called camelCase.\n\n\nNow, onto the cleaner creation of HTML elements in Javascript. We saw how we could do this with \ninnerHTML\n, but the better, more elegant way is with \ndocument.createElement\n. Here is an example:\n\n\nvar myDiv = document.createElement(\"div\");\n    myDiv.style.backgroundColor = \"red\";\n    myDiv.style.width = \"100px\";\n    myDiv.style.height = \"100px\";\n\nvar text = document.createElement(\"p\");\n    text.innerHTML = \"Created with JS\";\n\nmyDiv.appendChild(text);\n\ndocument.body.appendChild(myDiv);\n\n\n\nThis creates two elements with the \ndocument.createElement(elementName)\n function. Then we can apply our DOM properties to those in order to change their style/text. Then, using \nappendChild\n, we add first the \ntext\n element to \nmyDiv\n and then append \nmyDiv\n to our \ndocument.body\n. This is the equivalent of the following:\n\n\nHTML \n\n\nbody\n\n    \ndiv style=\"background-color:red; width: 100px; height: 100px\"\n \n        \np\nCreated With JS\n/p\n \n    \n/div\n\n\n/body\n\n\n\n\nConclusion\n\n\nCongratulations! You have succesfully learned the basics of Javascript. This will provide you with a base to start the rest of your learning. Check out the other projects we have on SDCoding to learn more. Get creative! The hardest part about programming is not remembering the syntax, that comes with practice, it's being able to use logic and creativity to solve problems and create new things.", 
            "title": "Introduction to JS"
        }, 
        {
            "location": "/BeginnerJavascript/#a-beginners-guide-to-javascript-by-gunner-spencer", 
            "text": "Hello there! Welcome to this course that will teach you all of the basics of the Javascript programming language. Javascript allows us to program applications and webpages for the web browser (like Google Chrome or Internet Explorer). Think of it as the brains of the operation, that works on the client side (which means it doesn't talk to the server), in order to provide your webpage with functionality. Let's just jump right in to start getting a better understanding!", 
            "title": "A Beginner's Guide to Javascript by Gunner Spencer"
        }, 
        {
            "location": "/BeginnerJavascript/#project-setup", 
            "text": "You will need a text editor (I recommend Atom.io or Textwrangler), but even Notepad will do. Setup a folder that will contain all of the files for this project, and name it something like JavascriptGuide (or don't, name it dankmemes if you want). And thats it! Open up your text editor and if you are using a more advanced text editor you can open up the path for your project folder and advance to the next step (don't worry if you can't, you will probably just need to leave the folder open in your system's file tree, i.e. Finder for Mac, so you can quickly access files inside of it.)", 
            "title": "Project Setup"
        }, 
        {
            "location": "/BeginnerJavascript/#part-1-two-worlds-collide-html-javascript", 
            "text": "The first thing we need to do before we even begin writing any Javascript is to create an  index.html  file. To do this, use your text editor to create a new file, then save that file as  index.html .  NOTE: Whenever you make changes to any file, you have to save it before seeing those changes reflected in the browser.  !DOCTYPE html  html   \n     head \n         title  Javascript Tutorial  /title \n     /head \n     body \n         script src=\"main.js\" /script \n     /body  /html   This just creates a basic HTML page that we can open up with the web browser of our choice (find the  index.html  file and right click it, then press open with and select the web browser). All we are doing on this webpage is giving it a title:  Javascript Tutorial  and then in our  body  tags, creating  script  tags to import our Javascript file by setting  src , standing for source, to our  main.js  file, which we will create next.", 
            "title": "Part 1: Two Worlds Collide, HTML &amp; Javascript"
        }, 
        {
            "location": "/BeginnerJavascript/#part-2-o-where-art-thou-variables", 
            "text": "Now it's time for our  main.js  file! Create it in the same way you created the  index.html  file, except of course with our new name,  main.js . Notice that a Javascript file will always have the extension  .js . This lets the browser know what type of file it is.  Open up your  main.js  and type the following:  var MyVariable = \"Hello World!\";\n\nconsole.log(MyVariable);  Now save this file and refresh your webpage. Nothing happened! Or so it seems. Right click the browser screen (if you are using Safari, switch to another browser, otherwise this won't work), and press Inspect Element, or Inspect. A box should pop up somewhere on your browser window that has the HTML code we wrote for our  index.html  file. Go to the top of that box and click where it says  Console . Here you will see the output of our function we just called,  console.log .   To call a function is to make that piece of code inside the function run. We pass what are called  parameters  to functions, the things inside the parentheses of the function call. These are used by the function, like how  console.log(text)  takes in the parameter  text  to output to the console.  The parameter that we passed into the function was actually a variable, specifically,  MyVariable , which had a value of  \"Hello World!\" . Variables are found in all programming langauges, as they allow us to store data for later use in our program. There are different types of data, for example: numbers, strings (which are just words or letters, like the value of  MyVariable ), and booleans. By creating a variable, we can, instead of using the string  \"Hello World!\" , just use the name of the variable,  MyVariable , in its place. The same goes for numbers in mathematical operations (which we will see in a moment) or boolean values (true or false) in conditional statements.   Below are examples of the different variables, including numbers, and the mathematical operations we can do with them.  var count = 5; // just a number\nvar num = 10.5; // a floating point number, or decimal\nvar product = count * num; // multiplication operator\nvar quotient = num / count; // division operator\nvar added = count + num; // addition operator\nvar subtracted = num - count; // subtraction operator\n\nproduct = quotient * added; \n/* notice that we don't have to add the keyword var \nafter we already created the variable. */\n\nsubtracted = product - subtracted; \n/* we can use the variable we are assigning a value to \ninside of the right-hand operation */\n\nvar crazyOperation = ((count * 5) / (product + added)) * quotient / 1.5; \n/* this demonstrates the order of operations, which is \nthe same as in your regular math class, but we use \nparentheses for nested statements that we want to make \nsure get evaluated first */  Try these out, using  console.log  to view the values you get. The  //  is a single line comment, so everything else after the  //  in that line is ignored. Same thing with the  /*   multiline comment   */  which can span multiple lines. Just make sure you open up with  /*  and then write your comment, then close it  */ .  var firstName = \"Johnny\";\nvar lastName = \"Appleseed\";\nvar fullName = firstName + \" \" + lastName;\n\nvar nameSize = fullName.length;  These are examples of how you can use  strings , the data type that allows you to store letters/characters in a variable. Note that  strings  have built-in attributes, like the  length  attribute that returns the length of that string. Also, we can combine, or concat,  string  with  +  signs. That's how we get the value for our  fullName  variable. Try using  console.log  to view the values!  var continue = false;\n// some stuff we do before we continue\ncontinue = true;  This is a boolean variable. It holds the value of either  true  or  false , which will allow us to evaluate conditional statements, a concept we will jump into next.", 
            "title": "Part 2: O, Where art Thou, Variables"
        }, 
        {
            "location": "/BeginnerJavascript/#part-3-its-true-javascript-is-the-language-for-you", 
            "text": "This next concept is crucial to programming. It is the conditional statement, which essentially checks if a condition is true or false, then does something accordingly. In Javascript, we have a few of these:  var count = 5,\n    measure = 20;\n\nif(count   measure) {\n    console.log(\"count is less than measure\");\n    if(count   measure / count) {\n        console.log(\"we can put if statements inside of if statements, and also use mathematical operations in the condition brackets!\");\n    }\n} else {\n    console.log(\"this code would run if the condition was not true.\");\n}  This is the most fundamental conditional statement, the  if else  statement. It checks if the condition inside the parentheses is true, and if it is it executes the code inside of the curly brackets. Otherwise, it executes the code following the  else  keyword. There are a few conditional operators we can use to compare values:  ==,  ,  ,  =,  =, != . These are pretty intuitive, meaning is equal to, greater than, less than, greater than or equal to, less than or equal to, and is not equal to, respectively.   var count = 0;\nwhile(count   10) {\n    console.log(count);\n    count++; // same thing as count += 1, count = count + 1\n}  This is a  while  loop, which executes the code inside the curly braces while the condition in the parentheses is true. Test out this piece of code, even see if you can make it count by two's or three's.   for(var count = 0; count   10; count++) {\n    console.log(count);\n}  This is a  for  loop, which essentially combines the components of a  while  loop necessary for iteration into one concise statement. This does the exact same thing as the previous conditional loop, except the syntax is different, since the iterator (or variable we increment) is declared inside the  for  statement, along with the condition to check and the iteration command  count++ .", 
            "title": "Part 3: It's True, Javascript is the Language for You"
        }, 
        {
            "location": "/BeginnerJavascript/#part-4-putting-the-fun-in-functions", 
            "text": "So far we have looked at Javascript code that executes in a linear fashion. This means that the Javascript engine, which runs our code, is starting from the top of our file and executes the code line by line until it reaches the end. Things like conditional statements and loops can skip over certain pieces of code, but for the most part, there is only linear progression. This is great, except for what if we wanted to do the same thing in two places in our code? Would we have to rewrite the same code? No! That's where functions come in. Functions act as blocks that contain code we can execute from anywhere in our program, again and again. We have already seen examples of this, like  console.log , which receives a parameter, like the text we want to output, and uses it inside of the code contained in that function. Let's take a look at how a function works in code!  function addTwoNumbers(num1, num2) {\n    var result = num1 + num2;\n    return result;\n}  This is a super simple function that takes in two parameters,  num1  and  num2  and adds them, storing that value in a variable we declare inside of the function called  result , then we return that  result .\nThis is how it could be used in practice:  console.log(\"2 + 5 is \" + addTwoNumbers(2, 5));  Sure, not super useful, since we could just handwrite that code just as fast as calling the function. However, as your computations or logic gets more complex, you need to organize it into functions, lest you wish to go insane. Here is a good example of this:  function raiseToPower(num, exponent) {\n    var result = 1;\n    for(var k = 0; k   exponent; k++) {\n        result *= num;\n    }\n    return result;\n}  This function is a bit more complex than just adding two powers, because as you might be able to tell, it raises a  num  to an  exponent  and returns that  result . This is still a fairly simple example, but you can see how it would be necessary to have a function like this rather than rewriting the tedious code everytime you wanted to use it.", 
            "title": "Part 4: Putting the Fun in Functions"
        }, 
        {
            "location": "/BeginnerJavascript/#part-5-simple-dom-for-your-dome", 
            "text": "So far we have only been manipulating variables we have created in our Javascript file, with no real effect on our webpage. DOM, which stands for the Document Object Model, solves this! DOM allows us to interact with our HTML elements so we can change our webpage from Javascript! Let's take a look at a few examples:  index.html       !DOCTYPE html  html   \n     head \n         title  Javascript Tutorial  /title \n     /head \n     body \n         !-- NEW STUFF -- \n             div id=\"myDiv\" /div \n             div class=\"coolClass\" /div \n             div class=\"coolClass\" /div \n         !-- END OF NEW STUFF -- \n         script src=\"main.js\" /script \n     /body  /html   main.js  var myDivVariable = document.getElementById(\"myDiv\");\nvar theCoolClassVariable = document.getElementsByClassName(\"coolClass\");\n\nmyDivVariable.innerHTML = \"Hello, folks!\";\n\nfor(var k = 0; k   theCoolClassVariable.length; k++) {\n    theCoolClassVariable[k].innerHTML = \"This is a part of the cool class\";\n}\n\ndocument.body.style.backgroundColor = \"red\";\ndocument.body.style.color = \"white\";  A lot to unpack here. The first thing we notice are these two variables we created:  myDivVariable  and  theCoolClassVariable . These each store the value returned by a built-in DOM function.  document.getElementById(id)  returns the element that matches that id from the HTML file. In this case, we would return the  div  with an  id  of  myDiv . The next DOM function,  document.getElementsByClassName(name)  returns an  array  of all the elements whose class matches that name. Essentially, an array is a data type that can store multiple values, and you can access those values by using square bracets  [index]  where the  index  starts at  0  and goes up to the  array.length - 1 , whatever that may be. Before we move on, here is a quixk example of arrays:  var myList = [\"hello\", \"my\", \"name\", \"is\", \"fred\"];\nvar fullSentence = \"\";\nfor(var k = 0; k   myList.length; k++) {\n    fullSentence += myList[k] + \" \";\n}\nconsole.log(fullSentence);\n\nconsole.log(\"The first word is \" + myList[0]);\nconsole.log(\"The last word is \" + myList[4]);  Try running this example and see the output. Arrays can also store numbers, booleans, or objects like our DOM function  document.getElementsByClassName  returns.  Now, back to the DOM example.  The property  innerHTML  of a DOM object allows us to manipulate whatever is inside of the tags. We could even add in another HTML element with this!   document.body.innerHTML += \" div id='yolo' /div \";\ndocument.getElementById(\"yolo\").innerHTML = \"yolo div\";  This is an easy way of manipulating our DOM, but not the best. It gets messy writing HTML is Javascript as a string. Notice that when we added the  div  with  innerHTML  and gave it an  id  we had to use  ''  single quotes instead of  \"\"  double quotes. This is because using two sets of double quotes would confuse the Javascript engine and give us an error. Theres a better way to create and add DOM objects in Javascript that we will go into in a moment.  The next thing we need to unpack is the  style  property of our DOM objects. We were able to manipulate the CSS of our HTML objects using this  style  property.   CSS  div {\n    background-color: red;\n}  Javascript  myObject.style.backgroundColor = \"red\";  These two statements, written in different languages, do the same thing, assuming they are both pointing to the same object. Take note of the syntax differences between them, like how in Javascript there aren't any  - 's and instead the first letter of the next word is capitalized. This practice is called camelCase.  Now, onto the cleaner creation of HTML elements in Javascript. We saw how we could do this with  innerHTML , but the better, more elegant way is with  document.createElement . Here is an example:  var myDiv = document.createElement(\"div\");\n    myDiv.style.backgroundColor = \"red\";\n    myDiv.style.width = \"100px\";\n    myDiv.style.height = \"100px\";\n\nvar text = document.createElement(\"p\");\n    text.innerHTML = \"Created with JS\";\n\nmyDiv.appendChild(text);\n\ndocument.body.appendChild(myDiv);  This creates two elements with the  document.createElement(elementName)  function. Then we can apply our DOM properties to those in order to change their style/text. Then, using  appendChild , we add first the  text  element to  myDiv  and then append  myDiv  to our  document.body . This is the equivalent of the following:  HTML   body \n     div style=\"background-color:red; width: 100px; height: 100px\"  \n         p Created With JS /p  \n     /div  /body", 
            "title": "Part 5: Simple DOM for your Dome"
        }, 
        {
            "location": "/BeginnerJavascript/#conclusion", 
            "text": "Congratulations! You have succesfully learned the basics of Javascript. This will provide you with a base to start the rest of your learning. Check out the other projects we have on SDCoding to learn more. Get creative! The hardest part about programming is not remembering the syntax, that comes with practice, it's being able to use logic and creativity to solve problems and create new things.", 
            "title": "Conclusion"
        }, 
        {
            "location": "/HTML5DrawingApp/", 
            "text": "Drawing App with HTML5 Canvas and Javascript\n\n\nPrerequisites: a brain and some basic knowledge of HTML and Javascript.\n\n\nEnd Product\n: a semi-functional, semi-user-friendly, super-cool web app that allows you to draw with your mouse and change the color/size/type of drawing tool.\n\n\nProject Setup\n\n\nYou will need a text editor (I recommend \nAtom.io\n or \nTextwrangler\n), but even Notepad will do. Setup a folder that will contain all of the files for this project, and name it something like \nJavascriptDrawingApp\n (or don't, name it dankmemes if you want). And thats it! Open up your text editor and if you are using a more advanced text editor you can open up the path for your project foldner and advance to the next step (don't worry if you can't, you will probably just need to leave the folder open in your system's file tree, i.e. Finder for Mac, so you can quickly access files inside of it.)\n\n\nIf you're on the web, you can use \nCodepen Projects\n\n\nStep 1\n\n\nCreate your \nindex.html\n file and add the following: \n\n\n!DOCTYPE html\n \n\nhtml\n\n    \nhead\n\n        \ntitle\n My cool drawing app \n/title\n\n        \nstyle\n\n            html, body {\n                margin: 0px;\n                padding: 0px;\n                overflow-x: hidden;\n            }\n        \n/style\n\n    \n/head\n\n    \nbody\n\n        \ncanvas id=\"paper\"\n/canvas\n\n        \nscript src=\"main.js\"\n/script\n\n    \n/body\n\n\n/html\n\n\n\n\nThis is just setting up a basic HTML file that has the small amount of CSS we need in a \nstyle\n tag. All the CSS is doing is making sure that our canvas will be able to take up the entire browser screen by eliminating any extra space. Then in our \nbody\n we have our \ncanvas id=\"paper\"\n/canvas\n that we will use in our Javascript to draw to, and then our \nscript\n tag requesting the Javascript resource, \nmain.js\n that we will create next.\n\n\nStep 2\n\n\nIn the same folder as your \nindex.html\n file, create a \nmain.js\n file and enter the following:\n\n\nvar canvas = document.getElementById(\"paper\"),\n    ctx = canvas.getContext(\"2d\"),\n    width = canvas.width = window.innerWidth,\n    height = canvas.height = window.innerHeight;\n\n\n\nThis Javascript code is initializing a couple of variables, the first being \ncanvas\n, which is initialized to a DOM (Document Object Model) function \ndocument.getElementById(id)\n that returns the HTML element with the corresponding id in our index.html file (in this case, our \ncanvas id=\"paper\"\n/canvas\n element. After this assignment we move onto our context variable, \nctx\n, which calls the function \ngetContext(\"2d\")\n on our recently created \ncanvas\n variable in order to return an object that we can use to draw onto our \ncanvas\n with. Finally, the variables \nwidth\n and \nheight\n are initiated and in a chain of assignment operatiosn are first set to the corresponding \ncanvas\n property, which in turn is assigned the value of \nwindow.innerWidth\n or \nwindow.innerHeight\n which is a Javascript engine model property that returns the full width and height of our browser screen in pixels, respectively. (NOTE: although the values of \nwindow.innerWidth\n and \nwindow.innerHeight\n are representative of pixels, their actual values are just numbers, i.e, \n600\n or \n920.60\n).\n\n\nStep 3\n\n\nNow it is time to add some event listeners! What are those? Well, the browser is waiting for you to interact with the computer (like its listening for something), and then when you do something, like press a key or move your mouse, it triggers what is called an \nevent\n which allows us as programmers to use that event data. We can add different kinds of \nlisteners\n to our HTML elements that perform different functions when different events are \"fired\" (which just means they happend, like a click).\n\n\nIn our \nmain.js\n file lets add some event listeners: \n\n\ncanvas.addEventListener(\"mousedown\", mouseDownEvent);\ncanvas.addEventListener(\"mousemove\", mouseMoveEvent);\ncanvas.addEventListener(\"mouseup\", mouseUpEvent);\n\n\n\nEach of these functions is adding a different type of listener to the \ncanvas\n. Each function takes in two parameters (those are the things within the parentheses separated by commas). The first parameter is in quotes, because it is a string value, and tells the function what type of listener to add to our \ncanvas\n object. The second parameter is a function that we want to be called (or executed) whenever that event fires. We will create these functions next.\n\n\nRight now our \nindex.html\n file should look the same as in \n Step 1\n, and our \nmain.js\n should look as follows:\n\n\nvar canvas = document.getElementById(\"paper\"),\nctx = canvas.getContext(\"2d\"),\nwidth = canvas.width = window.innerWidth,\nheight = canvas.height = window.innerHeight;\n\ncanvas.addEventListener(\"mousedown\", mouseDownEvent);\ncanvas.addEventListener(\"mousemove\", mouseMoveEvent);\ncanvas.addEventListener(\"mouseup\", mouseUpEvent);\n\n\n\nStep 4\n\n\nNow let's create those functions, known as \nEvent Handlers\n. \n\n\nAdd the following to your \nmain.js\n file:\n\n\nfunction mouseDownEvent(event) {\n    drawAt(event.clientX, event.clientY);\n    drawing = true;\n}\n\nfunction mouseMoveEvent(event) {\n    if(drawing) {\n        drawAt(event.clientX, event.clientY);\n    }\n}\n\nfunction mouseUpEvent() {\n    drawing = false;\n}\n\n\n\nThe first function, \nmouseDownEvent(event)\n is taking in the \nevent\n object as a parameter, and using its \nclientX\n and \nclientY\n properties in the \ndrawAt\n function, which we will create in a moment. It also sets the variable \ndrawing\n to true, something else that will be added in a moment.\n\n\nThe second function, \nmouseMoveEvent(event)\n is again taking in the \nevent\n parameter that is passed in by the event listener to check if we are drawing (a.k.a. if the mouse is being pressed), and if so then use the \ndrawAt\n function to draw at the \nclientX\n and \nclientY\n location.\n\n\nThe third function, \nmouseUpEvent()\n is going to simply set \ndrawing\n to false, so that way we aren't adding anything onto our \ncanvas\n when the mouse isn't being pressed.\n\n\nStep 5\n\n\nCreate the \ndrawAt\n function and a few other variables.\n\n\nIn our \nmain.js\n file lets add the \ndrawing\n variable.\n\n\nAt the top of our file, below our variables initializations, create a new variable:\n\n\nvar drawing = false;\n\n\n\nThis is going to help us check if we have the mouse pressed or not, and thus whether we should be drawing.\n\n\nAdd these other variables too:\n\n\nvar color = \"black\";\nvar size = 10;\nvar type = \"square\";\n\n\n\nNow we are going to make use of these new variables in our \ndrawAt\n function.\n\n\nLet's create that now, adding it below those variables we just made:\n\n\nfunction drawAt(x, y) {\n    ctx.fillStyle = color;\n    if(type.toLowerCase().trim() == \"square\") {\n        var kx = x - size / 2,\n            ky = y - size / 2;\n        ctx.fillRect(kx, ky, size, size);\n    } else if(type.toLowerCase().trim() == \"circle\") {\n        ctx.beginPath();\n        ctx.arc(x, y, size, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.closePath();\n    }\n}\n\n\n\nWow! Okay thats a hefty function, so let's dissect it a bit. \n\n\nAfter declaring the function (saying function and then the function name, \ndrawAt\n) with our \nx\n and \ny\n parameters, the first thing to notice is we assign \nctx.fillStyle\n to our \ncolor\n variable. This assures that whenever we draw it will always be in whatever value is stored in the \ncolor\n variable. \n\n\nThe next thing is component is an if, else if block that checks if our \ntype\n is a square or a circle. It converts our \ntype\n function to \ntoLowerCase\n and then uses \ntrim\n to get rid of excess white space. This ensures that the values are not case-sensitive.\n\n\nIf we move into our \nsquare\n part of the if, else if block, we will see some code that initializes two variables: \nkx\n and \nky\n. These are simply computing the coordinates of the midpoint of the square we want to draw by subtracting half of the \nsize\n variable from each value. Then, using the \nfillRect\n function on our \nctx\n variable, we can draw a rectangle at that location at the specified (x, y, width, height). Our \nsize\n variable takes care of the \nwidth\n and \nheight\n of our square, while our newly calculated midpoint coordinates take the place of \nx\n and \ny\n.\n\n\nMoving into our \ncircle\n part of the if, else if block we will see code for creating a circle in canvas. The first step is using \nbeginPath\n then using \narc(x, y, radius, startAngle, endAngle)\n to draw a circle. Here we use the raw \nx\n and \ny\n with our \nsize\n variable as the radius, and then \n0\n as our startAngle and \nMath.PI * 2\n as the endAngle in order to get a full circle. After this, we \nfill\n it and then \nclosePath\n.\n\n\nGreat job! Our drawing app is nearly completed. Your \nmain.js\n file should look like the following: \n\n\nvar canvas = document.getElementById(\"paper\"),\nctx = canvas.getContext(\"2d\"),\nwidth = canvas.width = window.innerWidth,\nheight = canvas.height = window.innerHeight;\n\nvar drawing = false;\nvar color = \"black\";\nvar size = 10;\nvar type = \"square\";\n\nfunction drawAt(x, y) {\n    ctx.fillStyle = color;\n    if(type.toLowerCase().trim() == \"square\") {\n        var kx = x - size / 2,\n            ky = y - size / 2;\n        ctx.fillRect(kx, ky, size, size);\n    } else if(type.toLowerCase().trim() == \"circle\") {\n        ctx.beginPath();\n        ctx.arc(x, y, size, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.closePath();\n    }\n}\n\ncanvas.addEventListener(\"mousedown\", mouseDownEvent);\ncanvas.addEventListener(\"mousemove\", mouseMoveEvent);\ncanvas.addEventListener(\"mouseup\", mouseUpEvent);\n\nfunction mouseDownEvent(event) {\n    drawAt(event.clientX, event.clientY);\n    drawing = true;\n}\n\nfunction mouseMoveEvent(event) {\n    if(drawing) {\n        drawAt(event.clientX, event.clientY);\n    }\n}\n\nfunction mouseUpEvent() {\n    drawing = false;\n}\n\n\n\nAt this point, you can start drawing on your browser by opening up the \nindex.html\n file in Google Chrome for example. However, there are a few more things we need to add in order to customize our drawing tool while we draw and save our drawings.\n\n\nStep 6\n\n\nNow we will add another listener, in order to receive keyboard input and change the values of our variables real-time.\n\n\nAdd the following event listener with the others you have already created in your \nmain.js\n.\n\n\ndocument.body.addEventListener(\"keydown\", keyDownEvent);\n\n\n\nNotice that we are using \ndocument.body\n and not \ncanvas\n this time.\n\n\nNow, let's create this event handler:\n\n\nfunction keyDownEvent(event) {\n    switch(event.keyCode) {\n        case 67: // c\n            color = prompt(\"What color do you want to draw with?\");\n            break;\n        case 83: // s \n            size = parseInt(prompt(\"What size do you want to draw with?\"));\n            break;\n        case 84: // t \n            type = prompt(\"What type of tip do you want to draw with? (square or circle)\");\n            break;\n    }\n}\n\n\n\nThe \nkeyDownEvent(event)\n function is going to use a \nswitch\n statement to check the value of \nevent.keyCode\n in order to see if any of the keys we care about were pressed. The \nswitch\n statement is going to go through case by case, entering the case block if the value in \nswitch(value)\n is equal to the value of the case. Once it reaches the end of the statement or a \nbreak\n it jumps out of the function. \n\n\nWe are checking if the keys \nc\n, \ns\n, and \nt\n, are pressed. When \nc\n is pressed we prompt the user for a new color. When \ns\n is pressed we prompt the user for a new size, and then use the \nparseInt\n function to retrieve an integer value from the string that is returned by \nprompt\n. Then if \nt\n is pressed we prompt the user for a new type. For all of these prompts we assign the return values to their respective variables.\nif we add in this function by our other event handlers and run the code, we should be able to change the color, size, and type of drawing tool we use by pressing the \nc\n, \ns\n, and \nt\n, keys, respectively.\n\n\nHome stretch! We have one final step to top off this lesson.\n\n\nStep 7\n\n\nNow we will be creating the functionality to save our beautiful drawings.\n\n\nIn our \nkeyDownEvent\n function, go into the \nswitch\n statement and after the last \nbreak\n add another \ncase\n like so:\n\n\ncase 32: // space bar\n    var imageData = canvas.toDataURL(),\n        name = \"Image\" + Date.now();\n    var download = document.createElement(\"a\");\n        download.setAttribute(\"href\", imageData);\n        download.setAttribute(\"download\", name);\n        download.innerHTML = name;\n\n    var br = document.createElement(\"br\");\n\n    document.body.appendChild(br);\n    document.body.appendChild(download);\n    break;\n\n\n\nThis \ncase\n will trigger when the spacebar is pressed, creating an \na\n/a\n tag with Javascript using the \ndocument.createElement(name)\n method, then setting it's \nhref\n attribute to the \nimageData\n which we retrieve with the \ncanvas.toDataURL\n function. This, in conjunction with the \ndownload\n attribute, will allow us to download the current image on our canvas. Next we set the \ninnerHTML\n so that a name displays, this name being a concatenation of \"Image\" and the current time in milliseconds using \nDate.now()\n. Next, we create a \nbr/\n element to space out our download links as they are created, then append these to our \ndocument.body\n, remembering to add the \nbreak\n at the end. \n\n\nGreat job!\n\n\nYou have succesfully created a drawing app where you can customize your brush and download your masterpieces. Be sure to share this with all of your friends!\n\n\nThe final status of \nmain.js\n is shown below:\n\n\nvar canvas = document.getElementById(\"paper\"),\nctx = canvas.getContext(\"2d\"),\nwidth = canvas.width = window.innerWidth,\nheight = canvas.height = window.innerHeight;\n\nvar drawing = false;\nvar color = \"black\";\nvar size = 10;\nvar type = \"square\";\n\nfunction drawAt(x, y) {\n    ctx.fillStyle = color;\n    if(type.toLowerCase().trim() == \"square\") {\n        var kx = x - size / 2,\n            ky = y - size / 2;\n        ctx.fillRect(kx, ky, size, size);\n    } else if(type.toLowerCase().trim() == \"circle\") {\n        ctx.beginPath();\n        ctx.arc(x, y, size, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.closePath();\n    }\n}\n\ncanvas.addEventListener(\"mousedown\", mouseDownEvent);\ncanvas.addEventListener(\"mousemove\", mouseMoveEvent);\ncanvas.addEventListener(\"mouseup\", mouseUpEvent);\ndocument.body.addEventListener(\"keydown\", keyDownEvent);\n\nfunction mouseDownEvent(event) {\n    drawAt(event.clientX, event.clientY);\n    drawing = true;\n}\n\nfunction mouseMoveEvent(event) {\n    if(drawing) {\n        drawAt(event.clientX, event.clientY);\n    }\n}\n\nfunction mouseUpEvent() {\n    drawing = false;\n}\n\nfunction keyDownEvent(event) {\n    switch(event.keyCode) {\n        case 67: // c\n            color = prompt(\"What color do you want to draw with?\");\n            break;\n        case 83: // s \n            size = parseInt(prompt(\"What size do you want to draw with?\"));\n            break;\n        case 84: // t \n            type = prompt(\"What type of tip do you want to draw with? (square or circle)\");\n            break;\n        case 32: // space bar\n            var imageData = canvas.toDataURL(),\n            name = \"Image\" + Date.now();\n            var download = document.createElement(\"a\");\n                download.setAttribute(\"href\", imageData);\n                download.setAttribute(\"download\", name);\n                download.innerHTML = name;\n\n            var br = document.createElement(\"br\");\n\n            document.body.appendChild(br);\n            document.body.appendChild(download);\n            break;\n    }\n}", 
            "title": "Drawing App Project"
        }, 
        {
            "location": "/HTML5DrawingApp/#drawing-app-with-html5-canvas-and-javascript", 
            "text": "Prerequisites: a brain and some basic knowledge of HTML and Javascript.  End Product : a semi-functional, semi-user-friendly, super-cool web app that allows you to draw with your mouse and change the color/size/type of drawing tool.", 
            "title": "Drawing App with HTML5 Canvas and Javascript"
        }, 
        {
            "location": "/HTML5DrawingApp/#project-setup", 
            "text": "You will need a text editor (I recommend  Atom.io  or  Textwrangler ), but even Notepad will do. Setup a folder that will contain all of the files for this project, and name it something like  JavascriptDrawingApp  (or don't, name it dankmemes if you want). And thats it! Open up your text editor and if you are using a more advanced text editor you can open up the path for your project foldner and advance to the next step (don't worry if you can't, you will probably just need to leave the folder open in your system's file tree, i.e. Finder for Mac, so you can quickly access files inside of it.)  If you're on the web, you can use  Codepen Projects", 
            "title": "Project Setup"
        }, 
        {
            "location": "/HTML5DrawingApp/#step-1", 
            "text": "Create your  index.html  file and add the following:   !DOCTYPE html   html \n     head \n         title  My cool drawing app  /title \n         style \n            html, body {\n                margin: 0px;\n                padding: 0px;\n                overflow-x: hidden;\n            }\n         /style \n     /head \n     body \n         canvas id=\"paper\" /canvas \n         script src=\"main.js\" /script \n     /body  /html   This is just setting up a basic HTML file that has the small amount of CSS we need in a  style  tag. All the CSS is doing is making sure that our canvas will be able to take up the entire browser screen by eliminating any extra space. Then in our  body  we have our  canvas id=\"paper\" /canvas  that we will use in our Javascript to draw to, and then our  script  tag requesting the Javascript resource,  main.js  that we will create next.", 
            "title": "Step 1"
        }, 
        {
            "location": "/HTML5DrawingApp/#step-2", 
            "text": "In the same folder as your  index.html  file, create a  main.js  file and enter the following:  var canvas = document.getElementById(\"paper\"),\n    ctx = canvas.getContext(\"2d\"),\n    width = canvas.width = window.innerWidth,\n    height = canvas.height = window.innerHeight;  This Javascript code is initializing a couple of variables, the first being  canvas , which is initialized to a DOM (Document Object Model) function  document.getElementById(id)  that returns the HTML element with the corresponding id in our index.html file (in this case, our  canvas id=\"paper\" /canvas  element. After this assignment we move onto our context variable,  ctx , which calls the function  getContext(\"2d\")  on our recently created  canvas  variable in order to return an object that we can use to draw onto our  canvas  with. Finally, the variables  width  and  height  are initiated and in a chain of assignment operatiosn are first set to the corresponding  canvas  property, which in turn is assigned the value of  window.innerWidth  or  window.innerHeight  which is a Javascript engine model property that returns the full width and height of our browser screen in pixels, respectively. (NOTE: although the values of  window.innerWidth  and  window.innerHeight  are representative of pixels, their actual values are just numbers, i.e,  600  or  920.60 ).", 
            "title": "Step 2"
        }, 
        {
            "location": "/HTML5DrawingApp/#step-3", 
            "text": "Now it is time to add some event listeners! What are those? Well, the browser is waiting for you to interact with the computer (like its listening for something), and then when you do something, like press a key or move your mouse, it triggers what is called an  event  which allows us as programmers to use that event data. We can add different kinds of  listeners  to our HTML elements that perform different functions when different events are \"fired\" (which just means they happend, like a click).  In our  main.js  file lets add some event listeners:   canvas.addEventListener(\"mousedown\", mouseDownEvent);\ncanvas.addEventListener(\"mousemove\", mouseMoveEvent);\ncanvas.addEventListener(\"mouseup\", mouseUpEvent);  Each of these functions is adding a different type of listener to the  canvas . Each function takes in two parameters (those are the things within the parentheses separated by commas). The first parameter is in quotes, because it is a string value, and tells the function what type of listener to add to our  canvas  object. The second parameter is a function that we want to be called (or executed) whenever that event fires. We will create these functions next.  Right now our  index.html  file should look the same as in   Step 1 , and our  main.js  should look as follows:  var canvas = document.getElementById(\"paper\"),\nctx = canvas.getContext(\"2d\"),\nwidth = canvas.width = window.innerWidth,\nheight = canvas.height = window.innerHeight;\n\ncanvas.addEventListener(\"mousedown\", mouseDownEvent);\ncanvas.addEventListener(\"mousemove\", mouseMoveEvent);\ncanvas.addEventListener(\"mouseup\", mouseUpEvent);", 
            "title": "Step 3"
        }, 
        {
            "location": "/HTML5DrawingApp/#step-4", 
            "text": "Now let's create those functions, known as  Event Handlers .   Add the following to your  main.js  file:  function mouseDownEvent(event) {\n    drawAt(event.clientX, event.clientY);\n    drawing = true;\n}\n\nfunction mouseMoveEvent(event) {\n    if(drawing) {\n        drawAt(event.clientX, event.clientY);\n    }\n}\n\nfunction mouseUpEvent() {\n    drawing = false;\n}  The first function,  mouseDownEvent(event)  is taking in the  event  object as a parameter, and using its  clientX  and  clientY  properties in the  drawAt  function, which we will create in a moment. It also sets the variable  drawing  to true, something else that will be added in a moment.  The second function,  mouseMoveEvent(event)  is again taking in the  event  parameter that is passed in by the event listener to check if we are drawing (a.k.a. if the mouse is being pressed), and if so then use the  drawAt  function to draw at the  clientX  and  clientY  location.  The third function,  mouseUpEvent()  is going to simply set  drawing  to false, so that way we aren't adding anything onto our  canvas  when the mouse isn't being pressed.", 
            "title": "Step 4"
        }, 
        {
            "location": "/HTML5DrawingApp/#step-5", 
            "text": "Create the  drawAt  function and a few other variables.  In our  main.js  file lets add the  drawing  variable.  At the top of our file, below our variables initializations, create a new variable:  var drawing = false;  This is going to help us check if we have the mouse pressed or not, and thus whether we should be drawing.  Add these other variables too:  var color = \"black\";\nvar size = 10;\nvar type = \"square\";  Now we are going to make use of these new variables in our  drawAt  function.  Let's create that now, adding it below those variables we just made:  function drawAt(x, y) {\n    ctx.fillStyle = color;\n    if(type.toLowerCase().trim() == \"square\") {\n        var kx = x - size / 2,\n            ky = y - size / 2;\n        ctx.fillRect(kx, ky, size, size);\n    } else if(type.toLowerCase().trim() == \"circle\") {\n        ctx.beginPath();\n        ctx.arc(x, y, size, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.closePath();\n    }\n}  Wow! Okay thats a hefty function, so let's dissect it a bit.   After declaring the function (saying function and then the function name,  drawAt ) with our  x  and  y  parameters, the first thing to notice is we assign  ctx.fillStyle  to our  color  variable. This assures that whenever we draw it will always be in whatever value is stored in the  color  variable.   The next thing is component is an if, else if block that checks if our  type  is a square or a circle. It converts our  type  function to  toLowerCase  and then uses  trim  to get rid of excess white space. This ensures that the values are not case-sensitive.  If we move into our  square  part of the if, else if block, we will see some code that initializes two variables:  kx  and  ky . These are simply computing the coordinates of the midpoint of the square we want to draw by subtracting half of the  size  variable from each value. Then, using the  fillRect  function on our  ctx  variable, we can draw a rectangle at that location at the specified (x, y, width, height). Our  size  variable takes care of the  width  and  height  of our square, while our newly calculated midpoint coordinates take the place of  x  and  y .  Moving into our  circle  part of the if, else if block we will see code for creating a circle in canvas. The first step is using  beginPath  then using  arc(x, y, radius, startAngle, endAngle)  to draw a circle. Here we use the raw  x  and  y  with our  size  variable as the radius, and then  0  as our startAngle and  Math.PI * 2  as the endAngle in order to get a full circle. After this, we  fill  it and then  closePath .  Great job! Our drawing app is nearly completed. Your  main.js  file should look like the following:   var canvas = document.getElementById(\"paper\"),\nctx = canvas.getContext(\"2d\"),\nwidth = canvas.width = window.innerWidth,\nheight = canvas.height = window.innerHeight;\n\nvar drawing = false;\nvar color = \"black\";\nvar size = 10;\nvar type = \"square\";\n\nfunction drawAt(x, y) {\n    ctx.fillStyle = color;\n    if(type.toLowerCase().trim() == \"square\") {\n        var kx = x - size / 2,\n            ky = y - size / 2;\n        ctx.fillRect(kx, ky, size, size);\n    } else if(type.toLowerCase().trim() == \"circle\") {\n        ctx.beginPath();\n        ctx.arc(x, y, size, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.closePath();\n    }\n}\n\ncanvas.addEventListener(\"mousedown\", mouseDownEvent);\ncanvas.addEventListener(\"mousemove\", mouseMoveEvent);\ncanvas.addEventListener(\"mouseup\", mouseUpEvent);\n\nfunction mouseDownEvent(event) {\n    drawAt(event.clientX, event.clientY);\n    drawing = true;\n}\n\nfunction mouseMoveEvent(event) {\n    if(drawing) {\n        drawAt(event.clientX, event.clientY);\n    }\n}\n\nfunction mouseUpEvent() {\n    drawing = false;\n}  At this point, you can start drawing on your browser by opening up the  index.html  file in Google Chrome for example. However, there are a few more things we need to add in order to customize our drawing tool while we draw and save our drawings.", 
            "title": "Step 5"
        }, 
        {
            "location": "/HTML5DrawingApp/#step-6", 
            "text": "Now we will add another listener, in order to receive keyboard input and change the values of our variables real-time.  Add the following event listener with the others you have already created in your  main.js .  document.body.addEventListener(\"keydown\", keyDownEvent);  Notice that we are using  document.body  and not  canvas  this time.  Now, let's create this event handler:  function keyDownEvent(event) {\n    switch(event.keyCode) {\n        case 67: // c\n            color = prompt(\"What color do you want to draw with?\");\n            break;\n        case 83: // s \n            size = parseInt(prompt(\"What size do you want to draw with?\"));\n            break;\n        case 84: // t \n            type = prompt(\"What type of tip do you want to draw with? (square or circle)\");\n            break;\n    }\n}  The  keyDownEvent(event)  function is going to use a  switch  statement to check the value of  event.keyCode  in order to see if any of the keys we care about were pressed. The  switch  statement is going to go through case by case, entering the case block if the value in  switch(value)  is equal to the value of the case. Once it reaches the end of the statement or a  break  it jumps out of the function.   We are checking if the keys  c ,  s , and  t , are pressed. When  c  is pressed we prompt the user for a new color. When  s  is pressed we prompt the user for a new size, and then use the  parseInt  function to retrieve an integer value from the string that is returned by  prompt . Then if  t  is pressed we prompt the user for a new type. For all of these prompts we assign the return values to their respective variables.\nif we add in this function by our other event handlers and run the code, we should be able to change the color, size, and type of drawing tool we use by pressing the  c ,  s , and  t , keys, respectively.  Home stretch! We have one final step to top off this lesson.", 
            "title": "Step 6"
        }, 
        {
            "location": "/HTML5DrawingApp/#step-7", 
            "text": "Now we will be creating the functionality to save our beautiful drawings.  In our  keyDownEvent  function, go into the  switch  statement and after the last  break  add another  case  like so:  case 32: // space bar\n    var imageData = canvas.toDataURL(),\n        name = \"Image\" + Date.now();\n    var download = document.createElement(\"a\");\n        download.setAttribute(\"href\", imageData);\n        download.setAttribute(\"download\", name);\n        download.innerHTML = name;\n\n    var br = document.createElement(\"br\");\n\n    document.body.appendChild(br);\n    document.body.appendChild(download);\n    break;  This  case  will trigger when the spacebar is pressed, creating an  a /a  tag with Javascript using the  document.createElement(name)  method, then setting it's  href  attribute to the  imageData  which we retrieve with the  canvas.toDataURL  function. This, in conjunction with the  download  attribute, will allow us to download the current image on our canvas. Next we set the  innerHTML  so that a name displays, this name being a concatenation of \"Image\" and the current time in milliseconds using  Date.now() . Next, we create a  br/  element to space out our download links as they are created, then append these to our  document.body , remembering to add the  break  at the end.   Great job!  You have succesfully created a drawing app where you can customize your brush and download your masterpieces. Be sure to share this with all of your friends!  The final status of  main.js  is shown below:  var canvas = document.getElementById(\"paper\"),\nctx = canvas.getContext(\"2d\"),\nwidth = canvas.width = window.innerWidth,\nheight = canvas.height = window.innerHeight;\n\nvar drawing = false;\nvar color = \"black\";\nvar size = 10;\nvar type = \"square\";\n\nfunction drawAt(x, y) {\n    ctx.fillStyle = color;\n    if(type.toLowerCase().trim() == \"square\") {\n        var kx = x - size / 2,\n            ky = y - size / 2;\n        ctx.fillRect(kx, ky, size, size);\n    } else if(type.toLowerCase().trim() == \"circle\") {\n        ctx.beginPath();\n        ctx.arc(x, y, size, 0, Math.PI * 2);\n        ctx.fill();\n        ctx.closePath();\n    }\n}\n\ncanvas.addEventListener(\"mousedown\", mouseDownEvent);\ncanvas.addEventListener(\"mousemove\", mouseMoveEvent);\ncanvas.addEventListener(\"mouseup\", mouseUpEvent);\ndocument.body.addEventListener(\"keydown\", keyDownEvent);\n\nfunction mouseDownEvent(event) {\n    drawAt(event.clientX, event.clientY);\n    drawing = true;\n}\n\nfunction mouseMoveEvent(event) {\n    if(drawing) {\n        drawAt(event.clientX, event.clientY);\n    }\n}\n\nfunction mouseUpEvent() {\n    drawing = false;\n}\n\nfunction keyDownEvent(event) {\n    switch(event.keyCode) {\n        case 67: // c\n            color = prompt(\"What color do you want to draw with?\");\n            break;\n        case 83: // s \n            size = parseInt(prompt(\"What size do you want to draw with?\"));\n            break;\n        case 84: // t \n            type = prompt(\"What type of tip do you want to draw with? (square or circle)\");\n            break;\n        case 32: // space bar\n            var imageData = canvas.toDataURL(),\n            name = \"Image\" + Date.now();\n            var download = document.createElement(\"a\");\n                download.setAttribute(\"href\", imageData);\n                download.setAttribute(\"download\", name);\n                download.innerHTML = name;\n\n            var br = document.createElement(\"br\");\n\n            document.body.appendChild(br);\n            document.body.appendChild(download);\n            break;\n    }\n}", 
            "title": "Step 7"
        }, 
        {
            "location": "/HTML5CanvasGame/", 
            "text": "Creating Pong with HTML5 Canvas by Gunner Spencer\n\n\nHola! In this course we will take a look at creating games with HTML5 canvas and Javascript. We go over the basics of rendering a view, updating the game state, and receiving user input. It applies most of the skills covered in the \nBeginner's Guide to Javascript\n, so if I recommend you check that out if you don't have much experience with Javascript. Let's get started!\n\n\nProject Setup\n\n\nYou will need a text editor (I recommend Atom.io or Textwrangler), but even Notepad will do. Setup a folder that will contain all of the files for this project, and name it something like JavascriptGuide (or don't, name it dankmemes if you want). And thats it! Open up your text editor and if you are using a more advanced text editor you can open up the path for your project folder and advance to the next step (don't worry if you can't, you will probably just need to leave the folder open in your system's file tree, i.e. Finder for Mac, so you can quickly access files inside of it.)\n\n\nPart 1: Setting the Stage\n\n\nThere is going to be very minimal HTML in this project, so let's just get that out of the way first:\n\n\nindex.html\n\n\n!DOCTYPE html\n\n\nhtml\n\n    \nhead\n\n        \ntitle\nLights, Camera, PONG!\n/title\n\n        \nstyle\n\n            html, body {\n                margin: 0px;\n                padding: 0px;\n                overflow: hidden;\n            }\n        \n/style\n\n    \n/head\n\n    \nbody\n\n        \nscript src=\"main.js\"\n/script\n\n    \n/body\n\n\n/html\n\n\n\n\nThis is just setting up a simple HTML page. The only items of interest are the \nstyle\n tag, which is using a bit of CSS to make sure our screen doesn't have any unneeded white space, and the \nscript\n tag which is just linking in our \nmain.js\n file which we will create next:\n\n\nmain.js\n\n\nvar canvas = document.createElement(\"canvas\"),\n    width = canvas.width = window.innerWidth,\n    height = canvas.height = window.innerHeight;\n\ndocument.body.appendChild(canvas);\n\nvar ctx = canvas.getContext(\"2d\");\n\nctx.fillRect(0, 0, width, height);\n\n\n\nThe first line of code should be familiar (if not, checkout Part 5 of the Beginner's Guide to Javascript). This just creates our DOM element of type \ncanvas\n. Then we are creating two variables, \nwidth\n and \nheight\n. We are setting those variables to the \ncanvas.width\n and \ncanvas.height\n respectively, which are in turn being assigned the value of \nwindow.innerWidth\n and \nwindow.innerHeight\n respectively. This ensures that our \ncanvas\n takes up the entire size of our browser screen, and then we store those values in easier-to-use variables like \nwidth\n and \nheight\n. If you wanted your game screen to be half the width and half the height of the screen, you would simply divide \nwindow.innerWidth\n or \nwindow.innerHeight\n divided by two in the assignment operation.\n\n\nThe next thing we do is put our canvas onto the body of our HTML page. Again, should be familiar code. Then we go into the most important variable for using HTML5 canvas, the \ncontext\n variable, or in this case we call it \nctx\n. This is what we use to render onto our canvas. So, by storing the value of \ncanvas.getContext(\"2d\")\n into a variable, we can draw onto the canvas in two dimensions. \n\n\nThat's where the next line comes in: \nctx.fillRect(x, y, width, height)\n. This takes in four parameters and draws a rectangle at that location, with that width and height, in the current \nctx.fillStyle\n, which by default is black. So by saving this and refreshing our index.html page in the browser, we should have a black screen. Perfect! \n\n\nPart 2: A Paddle for the Battle\n\n\nWe are going to take a look at objects in Javascript, which essentially act as encapsulations for variables and functions that are associated with a certain aspect of our program. This is going to be a simplified version of Javascript objects, so if you want a more in-depth look check out the \n OOPs, I Instantiated Again \n lesson on SDCoding.\n\n\nLet's get started:\n\n\nvar paddle = {\n    _x: 0,\n    _y: 0,\n    _width: 0,\n    _height: 0,\n\n    create: function(x, y, width, height) {\n        var p = Object.create(this);\n            p._x = x;\n            p._y = y;\n            p._width = width;\n            p._height = height;\n        return p;\n    },\n\n    render: function(c) {\n        c.fillRect(this._x, this._y, this._width, this._height);\n    },\n\n    setX: function(x) {\n        this._x = x\n    },\n\n    setY: function(y) {\n        this._y = y;\n    },\n\n    getX: function() {\n        return this._x;\n    },\n\n    getY: function() {\n        return this._y;\n    },\n\n    getWidth: function() {\n        return this._width;\n    },\n\n    getHeight: function() {\n        return this._height;\n    }\n};\n\n\n\nThis is our paddle object. We gave it some simple properties, like \n_x\n and \n_height\n, which by convention have the underscore before them. This isn't necessary though. Next we have our \ncreate\n function that takes in four parameters to use as properties. Here we are using the \nObject.create\n method of instantiating new objects in Javascript. After setting all of the properties, we return our new object. The four encapsulation functions, i.e., \ngetX\n, \ngetY\n, \nsetX\n, \nsetY\n, are there to facilitate the manipulation of our object's properties. The \nrender\n function is simply there to draw a rectangle with the object's properties, with the parameter being of type \ncontext\n so that we can draw to it. Let's create our two paddles now:\n\n\nvar playerPaddle = paddle.create(0, 0, 10, 100);\nvar enemyPaddle = paddle.create(width - 10, 0, 10, 100);\n\n\n\nThen let's create our \nupdate\n function to start rendering onto the screen. \n\n\nfunction update() {\n    ctx.fillStyle = \"black\";\n    ctx.fillRect(0, 0, width, height);\n\n    playerPaddle.render(ctx);\n    enemyPaddle.render(ctx);\n    requestAnimationFrame(update);\n}\n\n\n\nAnd then make sure we call the \nupdate\n function. Our complete \nmain.js\n file should look as follows:\n\n\nvar canvas = document.createElement(\"canvas\"),\n    width = canvas.width = window.innerWidth,\n    height = canvas.height = window.innerHeight;\n\ndocument.body.appendChild(canvas);\n\nvar ctx = canvas.getContext(\"2d\");\n\nctx.fillRect(0, 0, width, height);\n\n    var paddle = {\n    _x: 0,\n    _y: 0,\n    _width: 0,\n    _height: 0,\n\n    create: function(x, y, width, height) {\n        var p = Object.create(this);\n            p._x = x;\n            p._y = y;\n            p._width = width;\n            p._height = height;\n        return p;\n    },\n\n    render: function(c) {\n        c.fillRect(this._x, this._y, this._width, this._height);\n    },\n\n    setX: function(x) {\n        this._x = x\n    },\n\n    setY: function(y) {\n        this._y = y;\n    },\n\n    getX: function() {\n        return this._x;\n    },\n\n    getY: function() {\n        return this._y;\n    },\n\n    getWidth: function() {\n        return this._width;\n    },\n\n    getHeight: function() {\n        return this._height;\n    }\n};\n\nvar playerPaddle = paddle.create(0, 0, 10, 100);\nvar enemyPaddle = paddle.create(width - 10, 0, 10, 100);\n\nupdate();\n\nfunction update() {\n    ctx.fillStyle = \"black\";\n    ctx.fillRect(0, 0, width, height);\n\n    ctx.fillStyle = \"white\"; // change fill style to distinguish between the paddles and the background\n    playerPaddle.render(ctx);\n    enemyPaddle.render(ctx);\n    requestAnimationFrame(update);\n}\n\n\n\nPart 3: Mouse Becomes One With Paddle\n\n\nWe are going to dive into user input now, so that we can adjust the position of our paddle, and then also implement some very rudementary AI to get the enemy paddle moving. Let's start by adding our event listener:\n\n\ndocument.body.addEventListener(\"mousemove\", mouseMoveHandler);\n\nfunction mouseMoveHandler(event) {\n    playerPaddle.setY(event.clientY - playerPaddle.getHeight() / 2);\n}\n\n\n\nThis will readjust our paddle to wherever our mouse is, centering the paddle on our mouse.\n\n\nNow let's add the basic AI for our \nenemyPaddle\n:\n\n\nIn our \nupdate\n function, before we render the paddles, let's add a few conditional statements:\n\n\nvar enemyPos = enemyPaddle.getY();\n\n// if the paddle is at the top of the screen, start moving down\nif(enemyPos \n 0) {\n    enemyVelocity *= -1;\n}\n\n// if the paddle is at the bottom of the screen, start moving up\nif(enemyPos + enemyPaddle.getHeight() \n height) {\n    enemyVelocity *= -1;\n}\n\n    // update the position of the enemy paddle\nenemyPaddle.setY(enemyPos + enemyVelocity);\n\n\n\nThese will make sure the \nenemyPaddle\n will stay on screen, and will move between the two boundaries. We need to create the \nenemyVelocity\n variable though. Near the top of our \nmain.js\n file let's add this variable:\n\n\nvar enemyVelocity = 5;\n\n\n\nWe can adjust the value of this to make it go faster or slower (the bigger we make it, the faster it goes).\n\n\nPart 4: Let's Get the Ball Rolling\n\n\nNow it's time to create the \nball\n object. This one will be relatively simple, since we don't need to make multiple copies of it:\n\n\nvar ball = {\n    _x: width / 2, // center the ball \n    _y: height / 2, // center the ball\n    _vx: -4,\n    _vy: 4,\n    _size: 6,\n\n    update: function() {\n        this._x += this._vx;\n        this._y += this._vy;\n    },\n\n    render: function(c) {\n        c.beginPath();\n        c.arc(this._x, this._y, this._size, 0, Math.PI * 2);\n        c.fill();\n        c.closePath();\n    }\n};\n\n\n\nThe \nupdate\n function is here to make changing the position of our ball a little simpler, but it is not necessary. The \nrender\n function is utilizing the \ncontext.arc(x, y, radius, startAngle, endAngle)\n function to draw a circle, and then fill it. Our \n_vx\n and \n_vy\n properties stand for the velocity of their respective dimensions. This controls how fast the ball is going and where it is going. If we add the following to our \nupdate\n function:\n\n\nball.update();\n\n\n\nand then render it \n\n\nball.render(ctx);\n\n\n\nwe should see a white ball moving from the center to the bottom left of our screen.\n\n\nPart 5: Pong, I Think We Need to Set Some Boundaries\n\n\nWe are almost there! Now the next step is to make the ball change directions when we hit it with our paddle, and also check if we or the enemy has missed it. This will all take place in the \nupdate\n function.\n\n\nif(ball._y - ball._size \n 0 || ball._y + ball._size \n height) {\n    ball._vy *= -1;\n}\n\nif(ball._x - ball._size \n 0) {\n    if(ball._y \n= playerPaddle.getY() \n ball._y \n= playerPaddle.getY() + playerPaddle.getHeight()) {\n        ball._vx *= -1;\n    } else {\n        enemyScore++;\n        reset();\n    }\n}\n\nif(ball._x + ball._size \n width) {\n    if(ball._y \n= enemyPaddle.getY() \n ball._y \n= enemyrPaddle.getY() + enemyPaddle.getHeight()) {\n        ball._vx *= -1;\n    } else {\n        playerScore++;\n        reset();\n    }\n}\n\n\n\nThese conditional statement are what's called edge handling, and just check everytime the screen re-renders if the ball is going to leave it. If it is, then we change the velocity if its going vertically off the screen, or we check if the paddle hit it if its horizontally moving off the screen.\n\n\nThere is No Fairness in Love and War, Only in Keeping Score\n\n\nAlmost done! Now let's just add a way for us to see the scores. First, we need to create those variables, \nplayerScore\n and \nenemyScore\n. Near where we created the \nenemyVelocity\n variable, let's create these:\n\n\nvar enemyScore = 0,\n    playerScore = 0;\n\n\n\nThen, in our \nupdate\n function, lets add some code to render these scores:\n\n\nctx.fillText(playerScore, width / 4, height / 10);\nctx.fillText(enemyScore, width / 4 * 3, height / 10);\n\n\n\nNow, let's create that \nreset\n function so that our \nball\n will go back to the middle of the screen after a point has been scored.\n\n\nfunction reset() {\n    ball._x = width / 2;\n    ball._y = height / 2;\n    ball._vx *= -1;\n}\n\n\n\nGreat Job!\n\n\nYou have succesfully created your very own HTML5 Canvas game. If you want to improve on this game, here are some of my suggestions: Make the AI better (like it tries to follow the ball's movements), adjust the velocity of the ball every time it resets (so that it hits at different angles), and then also try to make the game always work in proportion to whatever screen it is being played on.\n\n\nThe final \nmain.js\n file should look as follows:\n\n\nvar canvas = document.createElement(\"canvas\"),\n    width = canvas.width = window.innerWidth,\n    height = canvas.height = window.innerHeight;\n\nvar enemyVelocity = 5;\nvar enemyScore = 0,\n    playerScore = 0;\n\ndocument.body.appendChild(canvas);\n\nvar ctx = canvas.getContext(\"2d\");\n\nctx.fillRect(0, 0, width, height);\n\n    var paddle = {\n    _x: 0,\n    _y: 0,\n    _width: 0,\n    _height: 0,\n    create: function(x, y, width, height) {\n        var p = Object.create(this);\n            p._x = x;\n            p._y = y;\n            p._width = width;\n            p._height = height;\n        return p;\n    },\n\n    render: function(c) {\n        c.fillRect(this._x, this._y, this._width, this._height);\n    },\n\n    setX: function(x) {\n        this._x = x\n    },\n\n    setY: function(y) {\n        this._y = y;\n    },\n\n    getX: function() {\n        return this._x;\n    },\n\n    getY: function() {\n        return this._y;\n    },\n\n        getWidth: function() {\n        return this._width;\n    },\n\n    getHeight: function() {\n        return this._height;\n    }\n};\n\nvar ball = {\n    _x: width / 2, // center the ball \n    _y: height / 2, // center the ball\n    _vx: -4,\n    _vy: 4,\n    _size: 6,\n\n    update: function() {\n        this._x += this._vx;\n        this._y += this._vy;\n    },\n\n    render: function(c) {\n        c.beginPath();\n        c.arc(this._x, this._y, this._size, 0, Math.PI * 2);\n        c.fill();\n        c.closePath();\n    }\n};\n\nvar playerPaddle = paddle.create(0, 0, 10, 100);\nvar enemyPaddle = paddle.create(width - 10, 0, 10, 100);\n\ndocument.body.addEventListener(\"mousemove\", mouseMoveHandler);\n\nfunction mouseMoveHandler(event) {\n    playerPaddle.setY(event.clientY - playerPaddle.getHeight() / 2);\n}\n\nfunction reset() {\n    ball._x = width / 2;\n    ball._y = height / 2;\nball._vx *= -1;\n}\n\nupdate();\n\nfunction update() {\n\n    ctx.fillStyle = \"black\";\n    ctx.fillRect(0, 0, width, height);\n\n    if(ball._y - ball._size \n 0 || ball._y + ball._size \n height) {\n    ball._vy *= -1;\n}\n\nif(ball._x - ball._size \n 0) {\n    if(ball._y \n= playerPaddle.getY() \n ball._y \n= playerPaddle.getY() + playerPaddle.getHeight()) {\n        ball._vx *= -1;\n    } else {\n    enemyScore++;\n  reset();\n    }\n}\n\nif(ball._x + ball._size \n width) {\n    if(ball._y \n= enemyPaddle.getY() \n ball._y \n= enemyPaddle.getY() + enemyPaddle.getHeight()) {\n        ball._vx *= -1;\n    } else {\nplayerScore++;\nreset();\n    }\n}\n\n    var enemyPos = enemyPaddle.getY();\n\n\n// if the paddle is at the top of the screen, start moving down\nif(enemyPos \n 0) {\n    enemyVelocity *= -1;\n}\n\n// if the paddle is at the bottom of the screen, start moving up\nif(enemyPos + enemyPaddle.getHeight() \n height) {\n    enemyVelocity *= -1;\n}\n\n    // update the position of the enemy paddle\nenemyPaddle.setY(enemyPos + enemyVelocity);\n\nball.update();\nctx.fillStyle = \"white\";\n    playerPaddle.render(ctx);\n    enemyPaddle.render(ctx);\nball.render(ctx);\n\n    ctx.fillText(playerScore, width / 4, height / 10);\nctx.fillText(enemyScore, width / 4 * 3, height / 10);\n    requestAnimationFrame(update);\n}\n\n\n\nCheckout the final result at \nhttps://jsfiddle.net/jshsdgkk/42/\n!", 
            "title": "Pong Game Project"
        }, 
        {
            "location": "/HTML5CanvasGame/#creating-pong-with-html5-canvas-by-gunner-spencer", 
            "text": "Hola! In this course we will take a look at creating games with HTML5 canvas and Javascript. We go over the basics of rendering a view, updating the game state, and receiving user input. It applies most of the skills covered in the  Beginner's Guide to Javascript , so if I recommend you check that out if you don't have much experience with Javascript. Let's get started!", 
            "title": "Creating Pong with HTML5 Canvas by Gunner Spencer"
        }, 
        {
            "location": "/HTML5CanvasGame/#project-setup", 
            "text": "You will need a text editor (I recommend Atom.io or Textwrangler), but even Notepad will do. Setup a folder that will contain all of the files for this project, and name it something like JavascriptGuide (or don't, name it dankmemes if you want). And thats it! Open up your text editor and if you are using a more advanced text editor you can open up the path for your project folder and advance to the next step (don't worry if you can't, you will probably just need to leave the folder open in your system's file tree, i.e. Finder for Mac, so you can quickly access files inside of it.)", 
            "title": "Project Setup"
        }, 
        {
            "location": "/HTML5CanvasGame/#part-1-setting-the-stage", 
            "text": "There is going to be very minimal HTML in this project, so let's just get that out of the way first:  index.html  !DOCTYPE html  html \n     head \n         title Lights, Camera, PONG! /title \n         style \n            html, body {\n                margin: 0px;\n                padding: 0px;\n                overflow: hidden;\n            }\n         /style \n     /head \n     body \n         script src=\"main.js\" /script \n     /body  /html   This is just setting up a simple HTML page. The only items of interest are the  style  tag, which is using a bit of CSS to make sure our screen doesn't have any unneeded white space, and the  script  tag which is just linking in our  main.js  file which we will create next:  main.js  var canvas = document.createElement(\"canvas\"),\n    width = canvas.width = window.innerWidth,\n    height = canvas.height = window.innerHeight;\n\ndocument.body.appendChild(canvas);\n\nvar ctx = canvas.getContext(\"2d\");\n\nctx.fillRect(0, 0, width, height);  The first line of code should be familiar (if not, checkout Part 5 of the Beginner's Guide to Javascript). This just creates our DOM element of type  canvas . Then we are creating two variables,  width  and  height . We are setting those variables to the  canvas.width  and  canvas.height  respectively, which are in turn being assigned the value of  window.innerWidth  and  window.innerHeight  respectively. This ensures that our  canvas  takes up the entire size of our browser screen, and then we store those values in easier-to-use variables like  width  and  height . If you wanted your game screen to be half the width and half the height of the screen, you would simply divide  window.innerWidth  or  window.innerHeight  divided by two in the assignment operation.  The next thing we do is put our canvas onto the body of our HTML page. Again, should be familiar code. Then we go into the most important variable for using HTML5 canvas, the  context  variable, or in this case we call it  ctx . This is what we use to render onto our canvas. So, by storing the value of  canvas.getContext(\"2d\")  into a variable, we can draw onto the canvas in two dimensions.   That's where the next line comes in:  ctx.fillRect(x, y, width, height) . This takes in four parameters and draws a rectangle at that location, with that width and height, in the current  ctx.fillStyle , which by default is black. So by saving this and refreshing our index.html page in the browser, we should have a black screen. Perfect!", 
            "title": "Part 1: Setting the Stage"
        }, 
        {
            "location": "/HTML5CanvasGame/#part-2-a-paddle-for-the-battle", 
            "text": "We are going to take a look at objects in Javascript, which essentially act as encapsulations for variables and functions that are associated with a certain aspect of our program. This is going to be a simplified version of Javascript objects, so if you want a more in-depth look check out the   OOPs, I Instantiated Again   lesson on SDCoding.  Let's get started:  var paddle = {\n    _x: 0,\n    _y: 0,\n    _width: 0,\n    _height: 0,\n\n    create: function(x, y, width, height) {\n        var p = Object.create(this);\n            p._x = x;\n            p._y = y;\n            p._width = width;\n            p._height = height;\n        return p;\n    },\n\n    render: function(c) {\n        c.fillRect(this._x, this._y, this._width, this._height);\n    },\n\n    setX: function(x) {\n        this._x = x\n    },\n\n    setY: function(y) {\n        this._y = y;\n    },\n\n    getX: function() {\n        return this._x;\n    },\n\n    getY: function() {\n        return this._y;\n    },\n\n    getWidth: function() {\n        return this._width;\n    },\n\n    getHeight: function() {\n        return this._height;\n    }\n};  This is our paddle object. We gave it some simple properties, like  _x  and  _height , which by convention have the underscore before them. This isn't necessary though. Next we have our  create  function that takes in four parameters to use as properties. Here we are using the  Object.create  method of instantiating new objects in Javascript. After setting all of the properties, we return our new object. The four encapsulation functions, i.e.,  getX ,  getY ,  setX ,  setY , are there to facilitate the manipulation of our object's properties. The  render  function is simply there to draw a rectangle with the object's properties, with the parameter being of type  context  so that we can draw to it. Let's create our two paddles now:  var playerPaddle = paddle.create(0, 0, 10, 100);\nvar enemyPaddle = paddle.create(width - 10, 0, 10, 100);  Then let's create our  update  function to start rendering onto the screen.   function update() {\n    ctx.fillStyle = \"black\";\n    ctx.fillRect(0, 0, width, height);\n\n    playerPaddle.render(ctx);\n    enemyPaddle.render(ctx);\n    requestAnimationFrame(update);\n}  And then make sure we call the  update  function. Our complete  main.js  file should look as follows:  var canvas = document.createElement(\"canvas\"),\n    width = canvas.width = window.innerWidth,\n    height = canvas.height = window.innerHeight;\n\ndocument.body.appendChild(canvas);\n\nvar ctx = canvas.getContext(\"2d\");\n\nctx.fillRect(0, 0, width, height);\n\n    var paddle = {\n    _x: 0,\n    _y: 0,\n    _width: 0,\n    _height: 0,\n\n    create: function(x, y, width, height) {\n        var p = Object.create(this);\n            p._x = x;\n            p._y = y;\n            p._width = width;\n            p._height = height;\n        return p;\n    },\n\n    render: function(c) {\n        c.fillRect(this._x, this._y, this._width, this._height);\n    },\n\n    setX: function(x) {\n        this._x = x\n    },\n\n    setY: function(y) {\n        this._y = y;\n    },\n\n    getX: function() {\n        return this._x;\n    },\n\n    getY: function() {\n        return this._y;\n    },\n\n    getWidth: function() {\n        return this._width;\n    },\n\n    getHeight: function() {\n        return this._height;\n    }\n};\n\nvar playerPaddle = paddle.create(0, 0, 10, 100);\nvar enemyPaddle = paddle.create(width - 10, 0, 10, 100);\n\nupdate();\n\nfunction update() {\n    ctx.fillStyle = \"black\";\n    ctx.fillRect(0, 0, width, height);\n\n    ctx.fillStyle = \"white\"; // change fill style to distinguish between the paddles and the background\n    playerPaddle.render(ctx);\n    enemyPaddle.render(ctx);\n    requestAnimationFrame(update);\n}", 
            "title": "Part 2: A Paddle for the Battle"
        }, 
        {
            "location": "/HTML5CanvasGame/#part-3-mouse-becomes-one-with-paddle", 
            "text": "We are going to dive into user input now, so that we can adjust the position of our paddle, and then also implement some very rudementary AI to get the enemy paddle moving. Let's start by adding our event listener:  document.body.addEventListener(\"mousemove\", mouseMoveHandler);\n\nfunction mouseMoveHandler(event) {\n    playerPaddle.setY(event.clientY - playerPaddle.getHeight() / 2);\n}  This will readjust our paddle to wherever our mouse is, centering the paddle on our mouse.  Now let's add the basic AI for our  enemyPaddle :  In our  update  function, before we render the paddles, let's add a few conditional statements:  var enemyPos = enemyPaddle.getY();\n\n// if the paddle is at the top of the screen, start moving down\nif(enemyPos   0) {\n    enemyVelocity *= -1;\n}\n\n// if the paddle is at the bottom of the screen, start moving up\nif(enemyPos + enemyPaddle.getHeight()   height) {\n    enemyVelocity *= -1;\n}\n\n    // update the position of the enemy paddle\nenemyPaddle.setY(enemyPos + enemyVelocity);  These will make sure the  enemyPaddle  will stay on screen, and will move between the two boundaries. We need to create the  enemyVelocity  variable though. Near the top of our  main.js  file let's add this variable:  var enemyVelocity = 5;  We can adjust the value of this to make it go faster or slower (the bigger we make it, the faster it goes).", 
            "title": "Part 3: Mouse Becomes One With Paddle"
        }, 
        {
            "location": "/HTML5CanvasGame/#part-4-lets-get-the-ball-rolling", 
            "text": "Now it's time to create the  ball  object. This one will be relatively simple, since we don't need to make multiple copies of it:  var ball = {\n    _x: width / 2, // center the ball \n    _y: height / 2, // center the ball\n    _vx: -4,\n    _vy: 4,\n    _size: 6,\n\n    update: function() {\n        this._x += this._vx;\n        this._y += this._vy;\n    },\n\n    render: function(c) {\n        c.beginPath();\n        c.arc(this._x, this._y, this._size, 0, Math.PI * 2);\n        c.fill();\n        c.closePath();\n    }\n};  The  update  function is here to make changing the position of our ball a little simpler, but it is not necessary. The  render  function is utilizing the  context.arc(x, y, radius, startAngle, endAngle)  function to draw a circle, and then fill it. Our  _vx  and  _vy  properties stand for the velocity of their respective dimensions. This controls how fast the ball is going and where it is going. If we add the following to our  update  function:  ball.update();  and then render it   ball.render(ctx);  we should see a white ball moving from the center to the bottom left of our screen.", 
            "title": "Part 4: Let's Get the Ball Rolling"
        }, 
        {
            "location": "/HTML5CanvasGame/#part-5-pong-i-think-we-need-to-set-some-boundaries", 
            "text": "We are almost there! Now the next step is to make the ball change directions when we hit it with our paddle, and also check if we or the enemy has missed it. This will all take place in the  update  function.  if(ball._y - ball._size   0 || ball._y + ball._size   height) {\n    ball._vy *= -1;\n}\n\nif(ball._x - ball._size   0) {\n    if(ball._y  = playerPaddle.getY()   ball._y  = playerPaddle.getY() + playerPaddle.getHeight()) {\n        ball._vx *= -1;\n    } else {\n        enemyScore++;\n        reset();\n    }\n}\n\nif(ball._x + ball._size   width) {\n    if(ball._y  = enemyPaddle.getY()   ball._y  = enemyrPaddle.getY() + enemyPaddle.getHeight()) {\n        ball._vx *= -1;\n    } else {\n        playerScore++;\n        reset();\n    }\n}  These conditional statement are what's called edge handling, and just check everytime the screen re-renders if the ball is going to leave it. If it is, then we change the velocity if its going vertically off the screen, or we check if the paddle hit it if its horizontally moving off the screen.", 
            "title": "Part 5: Pong, I Think We Need to Set Some Boundaries"
        }, 
        {
            "location": "/HTML5CanvasGame/#there-is-no-fairness-in-love-and-war-only-in-keeping-score", 
            "text": "Almost done! Now let's just add a way for us to see the scores. First, we need to create those variables,  playerScore  and  enemyScore . Near where we created the  enemyVelocity  variable, let's create these:  var enemyScore = 0,\n    playerScore = 0;  Then, in our  update  function, lets add some code to render these scores:  ctx.fillText(playerScore, width / 4, height / 10);\nctx.fillText(enemyScore, width / 4 * 3, height / 10);  Now, let's create that  reset  function so that our  ball  will go back to the middle of the screen after a point has been scored.  function reset() {\n    ball._x = width / 2;\n    ball._y = height / 2;\n    ball._vx *= -1;\n}", 
            "title": "There is No Fairness in Love and War, Only in Keeping Score"
        }, 
        {
            "location": "/HTML5CanvasGame/#great-job", 
            "text": "You have succesfully created your very own HTML5 Canvas game. If you want to improve on this game, here are some of my suggestions: Make the AI better (like it tries to follow the ball's movements), adjust the velocity of the ball every time it resets (so that it hits at different angles), and then also try to make the game always work in proportion to whatever screen it is being played on.  The final  main.js  file should look as follows:  var canvas = document.createElement(\"canvas\"),\n    width = canvas.width = window.innerWidth,\n    height = canvas.height = window.innerHeight;\n\nvar enemyVelocity = 5;\nvar enemyScore = 0,\n    playerScore = 0;\n\ndocument.body.appendChild(canvas);\n\nvar ctx = canvas.getContext(\"2d\");\n\nctx.fillRect(0, 0, width, height);\n\n    var paddle = {\n    _x: 0,\n    _y: 0,\n    _width: 0,\n    _height: 0,\n    create: function(x, y, width, height) {\n        var p = Object.create(this);\n            p._x = x;\n            p._y = y;\n            p._width = width;\n            p._height = height;\n        return p;\n    },\n\n    render: function(c) {\n        c.fillRect(this._x, this._y, this._width, this._height);\n    },\n\n    setX: function(x) {\n        this._x = x\n    },\n\n    setY: function(y) {\n        this._y = y;\n    },\n\n    getX: function() {\n        return this._x;\n    },\n\n    getY: function() {\n        return this._y;\n    },\n\n        getWidth: function() {\n        return this._width;\n    },\n\n    getHeight: function() {\n        return this._height;\n    }\n};\n\nvar ball = {\n    _x: width / 2, // center the ball \n    _y: height / 2, // center the ball\n    _vx: -4,\n    _vy: 4,\n    _size: 6,\n\n    update: function() {\n        this._x += this._vx;\n        this._y += this._vy;\n    },\n\n    render: function(c) {\n        c.beginPath();\n        c.arc(this._x, this._y, this._size, 0, Math.PI * 2);\n        c.fill();\n        c.closePath();\n    }\n};\n\nvar playerPaddle = paddle.create(0, 0, 10, 100);\nvar enemyPaddle = paddle.create(width - 10, 0, 10, 100);\n\ndocument.body.addEventListener(\"mousemove\", mouseMoveHandler);\n\nfunction mouseMoveHandler(event) {\n    playerPaddle.setY(event.clientY - playerPaddle.getHeight() / 2);\n}\n\nfunction reset() {\n    ball._x = width / 2;\n    ball._y = height / 2;\nball._vx *= -1;\n}\n\nupdate();\n\nfunction update() {\n\n    ctx.fillStyle = \"black\";\n    ctx.fillRect(0, 0, width, height);\n\n    if(ball._y - ball._size   0 || ball._y + ball._size   height) {\n    ball._vy *= -1;\n}\n\nif(ball._x - ball._size   0) {\n    if(ball._y  = playerPaddle.getY()   ball._y  = playerPaddle.getY() + playerPaddle.getHeight()) {\n        ball._vx *= -1;\n    } else {\n    enemyScore++;\n  reset();\n    }\n}\n\nif(ball._x + ball._size   width) {\n    if(ball._y  = enemyPaddle.getY()   ball._y  = enemyPaddle.getY() + enemyPaddle.getHeight()) {\n        ball._vx *= -1;\n    } else {\nplayerScore++;\nreset();\n    }\n}\n\n    var enemyPos = enemyPaddle.getY();\n\n\n// if the paddle is at the top of the screen, start moving down\nif(enemyPos   0) {\n    enemyVelocity *= -1;\n}\n\n// if the paddle is at the bottom of the screen, start moving up\nif(enemyPos + enemyPaddle.getHeight()   height) {\n    enemyVelocity *= -1;\n}\n\n    // update the position of the enemy paddle\nenemyPaddle.setY(enemyPos + enemyVelocity);\n\nball.update();\nctx.fillStyle = \"white\";\n    playerPaddle.render(ctx);\n    enemyPaddle.render(ctx);\nball.render(ctx);\n\n    ctx.fillText(playerScore, width / 4, height / 10);\nctx.fillText(enemyScore, width / 4 * 3, height / 10);\n    requestAnimationFrame(update);\n}  Checkout the final result at  https://jsfiddle.net/jshsdgkk/42/ !", 
            "title": "Great Job!"
        }
    ]
}